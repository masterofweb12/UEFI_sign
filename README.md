# Ubuntu 22.04 исполнение только подписанного кода


## Зададимся задачей исполнять на целевой системе только подписаный ( доверенный ) код.

Во исполнение этой задачи нам необходим обеспечить следующее:
1) безопасную загрузку доверенного подписанного кода ядра Linux
2) загрузку исключительно подписанных драйверов ( модулей ядра Linux )
3) доверенную инициализацию пользовательского пространства ( процесс init )
4) исполнение только подписанных бинарных файлов

### Безопасная загрузка доверенного подписанного кода ядра Linux

 Если *ядро Linux* скомпилировано с параметром *CONFIG_EFI_STUB* ( а в ubuntu это именно так ), то оно поддерживает загрузку напрямую из *UEFI*.
Таким образом мы можем перенести *ядро* в *ESP* ( *EFI System Partition* ) располженный обычно в */boot/efi*, настроить UEFI таким образом, чтоб *ядро* грузилось напрямую, и всё должно работать.
 Однако это не будет полноценным решением, потому как *ядру* надо передать в качестве параметра образ *initramfs*, целостность которого мы никоим образом не можем проверить, что влечёт за собой возможность подмены образа *initramfs* с последующей компроментацией всей системы.
 Во избежание изложенного выше мы должны объединить *ядро* и образ *initramfs* в единый испонимый файл и запускать напрямую его. К счастью такая возможность существует. 
 
 Прежде чем подписывать код ядра, мы должны сгенерировать ключи, которыми мы будем подписывать ядро и всё остальное. Для этого нам понадобится скрипт
 [UEFI/MOK_KEYS/make_keys.sh](/UEFI/MOK_KEYS/make_keys.sh).

 Этот скрипт запросит имя ключа ( оно же будет выступать в качестве Common Name сертификата ).
Запустим скрипт и для примера назовём наш ключ **masterkey**. Скрипт сгенерирует следующие файлы и каталоги:  
keys  
masterkey.GUID.txt  
masterkey.cer  
masterkey.cer.siglist  
masterkey.crt  
masterkey.key

 В файлах *masterkey.crt* и *masterkey.key* содержатся сертификат и его приватный ключ. В файле *masterkey.cer* тот же сертификат в формате *DER*.
Также скрипт генерирует произвольный *UUID* и сохраняет его в файл *masterkey.GUID.txt*.
 На основе файлов *masterkey.GUID.txt* и *masterkey.cer* генерируется *siglist*.  
**siglist** является специальным видом файла экспорт которого возможен в энергонезависимую памят *UEFI*.  
В каталоге *keys* будут созданы следующие подкаталоги:  
PK  
KEK  
db  
dbx  
Назначение этих подкаталогов следующее:  
**Platform Key (PK)** — публичный ключ владельца платформы. Подписи соответствующим приватным ключом необходимы для смены PK или изменения KEK, db и dbx (описаны далее). Хранилище PK должно быть защищено от вмешательства и удаления.  
**Key Exchange Key (KEK)** — публичные ключи операционных систем. Подписи соответствующими приватными ключами необходимы для изменения баз данных подписей (db, dbx, описаны далее). Хранилище KEK должно быть защищено от вмешательства.  
**Базы данных подписей (db, dbx)** — Базы данных подписей и хешей доверенных приложений (db) и недоверенных приложений (dbx).  

В нашем случае мы имеем самоподписанный сертификат, потому мы можем записать наш открытый ключ и в *PK*, и в *KEK* и в *db*.
Для этого нам нужно зайти в UEFI полностю очистить его от ключей, которые там содержатся и перевести **Secure Boot** в режим **Setup Mode**.  
После этого нужно вызвать скрипт  [UEFI/MOK_KEYS/save_keys.sh](/UEFI/MOK_KEYS/save_keys.sh), который запишет данные ключи ( по сути наш один самоподписанный ключ ) в энергонезависимую память UEFI.  

Теперь мы можем подписать ядро и пергрузившись включить **Secure Boot**.  
Для начала объединим *ядро* и  *initramfs*.  
Сначала подпишем *ядро*. Для этого запустим скрипт [UEFI/MOK_KEYS/sign.sh](/UEFI/MOK_KEYS/sign.sh) передав ему в качестве параметра путь к подписываему ядру. Скрипт запросит имя ключа, в нашем случае мы введём *masterkey* и *ядро* будет успешно подписано. результатом подписи будет файл с именем ИМЯ_ЯДРА-signed. Скопируем этот файл на место оригинального *ядра* и удалим его ( например так *ИМЯ_ЯДРА-signed* > *ИМЯ_ЯДРА* ).  
Теперь можем приступать к объединению *ядра* и *initramfs*. Для этого зайдём в каталог [/UEFI/MAKE_UEFI](/UEFI/MAKE_UEFI)  запустим скрипт [/UEFI/MAKE_UEFI/make_uefi_exe.sh](/UEFI/MAKE_UEFI/make_uefi_exe.sh). Предварительно в этом скрипте нужно поправить переменную *EFIFOLDER* введя в качестве её значения имя каталога, куда будут помещаться готовые объединённые с *initramfs* *ядра*. После отработки скрипта в означенном выше каталоге заданном переменной *EFIFOLDER* появится файл *vmlinuz*, который и будет нужным нам ядром. Вернёмся в [UEFI/MOK_KEYS](/UEFI/MOK_KEYS) и подпишем его при помощи [UEFI/MOK_KEYS/sign.sh](/UEFI/MOK_KEYS/sign.sh).  

Теперь можем перегружаться и переводит **Secure Boot** в режим максимальной защиты.


### Подписание драйверов ( модулей ядра Linux )

В случае с *ubuntu* модули *ядра* уже подписаны ключами *Canonical* встроенными в *ядро* при его компиляции, а при включении **Secure Boot** *ядро* начинает автоматически проверять подпись загружаемых модулей.  
Однако в случае если у нас имеются некоторые модули собранные самостоятельно, то для того, чтоб они вгрузились в пространство ядра, мы обязаны их подписать либо ключём *Canonical* ( доступа к которому у нас нет ), либо тем ключём, который хранится в энергонезависимой памяти *UEFI* в *db*.  
А это наш ключ, который мы и загрузили на прошлом этапе.  
Для подписывания модулей ядра следует применять скрипт [UEFI/MOK_KEYS/sign_k_module](/UEFI/MOK_KEYS/sign_k_module) действие которого аналогично действию [UEFI/MOK_KEYS/sign.sh](/UEFI/MOK_KEYS/sign.sh) за исключением того, что модуль ядра подписывается напрямую без создания промежуточного файла *-signed*.


### Исполнение только подписанных бинарных файлов

Для контроля целостности исполняемых ( да и любых файлов ) в *Linux* применяются подсистемы безопасности **IMA** и **EVM**.  

Подсистема *Linux Integrity Measurement Architecture* (*IMA*) отвечает за вычисление хэшей файлов и программ перед их загрузкой, а также поддерживает отчеты по хэшам и проверяет, соответствуют ли они предварительно определенному списку.  
Хеши хранятся в расширенных атрибутах файловой системы, соответственно никакой речи об *IMA* быть не может, если целевая файловая система не поддерживает расширенные атрибуты. Хеши хранятся в атрибуте **security.ima**.

*EVM* (*Extended Verification Module*) служит для защиты от несанкционированного доступа к файлам в автономном режиме. Цель здесь состоит в том, чтобы обнаружить, когда файлы на диске были изменены, когда система была выключена. *EVM* хранит свои даные в атрибуте **security.evm** и защищает чувствительные метаданные файла такие как: *хеши IMA*, *данные selinux*, данные *apparmor* и другие.
**security.evm** может содержать в себе либо хеш, подписанный закрытым ключём, либо может содержать в себе *HMAC* ( *Hash-based Message Authentication Code* ).  

В случае когда *EVM* использует подписанный хэш это работает аналогично оценке *IMA*: вычисляется хэш собранных метаданных. Затем делается подпись для хэша с использованием криптографии с открытым ключом. Когда *EVM* активен, доступ будет разрешен только к тем файлам, для которых можно проверить хэш и подпись. Данный метод подходит только для статических файлов, поскольку мы заранее подписываем файлы и в случае, если файл изменён, то в виду отсутствия на машине закрытого ключа ( во всяком случае его отсутствия в открытом виде ) хеш не может быть повторно вычилен и подписан.  

В случае если *EVM* использует *HMAC*, метаданные файла можно аутентифицировать с помощью симметричного ключа. Симметричный ключ лучше всего хранить на микросхеме TPM. Таким образом, симметричный ключ доступен только после успешной доверенной загрузки. Также ключ никогда не покидает микросхему **TPM**.
Функциональное отличие от *EVM* на основе цифровых подписей заключается в том, что симметричный ключ будет доступен во время обычной работы, поэтому подсистема *IMA/EVM* может пересчитывать *HMAC* при изменении файлов. Таким образом, подход *EVM* *HMAC* также подходит для файлов, которые регулярно изменяются, например, для файлов баз данных.

Мы рассмотрим здесь работу *EVM* в режиме подписанного хеша.  







